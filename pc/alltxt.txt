from cdecimal import Decimal
import CustomMath as custommath
def DemocracyRep(x):
    v=[]
    for i in range(len(x)):
        v.append(1)
    return(custommath.ReWeight(v))
def GetRewardWeights(M, Rep=-1, alpha=Decimal('0.1')):
    if Rep==-1:
        Rep=DemocracyRep(M)
    if type(Rep[0])==list:
        Rep=map(lambda x: x[0], Rep)
    Results=custommath.WeightedPrinComp(M, Rep)
    FirstLoading=Results['Loadings']
    FirstScore=Results['Scores']
    a=min(map(abs,FirstScore))
    b=max(FirstScore)
    Set1=map(lambda x: x+a, FirstScore)
    Set2=map(lambda x: x-b, FirstScore)
    Old=custommath.dot([Rep], M)
    New1=custommath.dot([custommath.GetWeight(Set1)], M)
    New2=custommath.dot([custommath.GetWeight(Set2)], M)
    def sub_f(a, b): return a-b
    def f(n): return sum(map(lambda x: x**2, map(sub_f, n[0], Old[0])))
    RefInd=f(New1)-f(New2)
    if(RefInd<=0): AdjPrinComp = Set1  
    else: AdjPrinComp = Set2  
    RowRewardWeighted=Rep
    if max(map(abs,AdjPrinComp))!=0:
        m=custommath.mean(Rep)
        RRW=[]
        for i in range(len(Rep)):
            RRW.append(AdjPrinComp[i]*Rep[i]/m)
        RowRewardWeighted=custommath.GetWeight(RRW)
    SmoothedR=[]
    for i in range(len(Rep)):
        SmoothedR.append(alpha*RowRewardWeighted[i]+(1-alpha)*Rep[i])
    Out = {"FirstL":FirstLoading, "OldRep":Rep, "ThisRep":RowRewardWeighted, "SmoothRep":SmoothedR}  
    return(Out)
def v_dot(a, b): 
    def mul(c, d): return c*d
    return sum(map(mul, a, b))
def GetDecisionOutcomes(Mtemp, Rep):
# Determines the Outcomes of Decisions based on the provided reputation (weighted vote)
    #For each column
    out=[]
    for i in range(len(Mtemp[0])):
        Row=[]
        Col=[]
        c=map(lambda x: x[i], Mtemp)
        for j in range(len(c)):
            if type(c[j]) not in [str, unicode]:
                Row.append(Rep[j])
                Col.append(c[j])
        Row=custommath.ReWeight(Row)
        out.append(v_dot(Col, Row))
    return custommath.switch_row_cols(out)
def any_NA(M):
    for row in M:
        for i in row:
            if i=='NA': return True
    return False
def diag(v):
    if type(v[0])==list: v=v[0]
    out=[]
    l=len(v)
    for i in range(l):
        row=[0]*l
        row[i]=v[i]
        out.append(row)
    return out
def FillNa(Mna, Rep, Catchp=Decimal('0.1')):
    Mnew = Mna
    MnewC=Mna
    if any_NA(Mna):
        DecisionOutcomesRaw=GetDecisionOutcomes(Mna, Rep)
        NAmat=map(lambda row: map(lambda x: 1 if x=='NA' else 0, row), Mna)
        Mnew=map(lambda row: map(lambda x: 0 if x=='NA' else x, row), Mna)
        NAsToFill=custommath.dot(NAmat, diag(DecisionOutcomesRaw))
        for row in range(len(Mnew)):
            for i in range(len(Mnew[row])):
                Mnew[row][i]=Mnew[row][i]+NAsToFill[row][i]
        return(map(lambda row: map(lambda x: custommath.Catch(x, Catchp), row), Mnew))
    return(Mna)
def Factory(M0, Rep, CatchP=Decimal('0.1'), MaxRow=5000):
    Rep=custommath.ReWeight(Rep)
    Filled=FillNa(M0, Rep, CatchP)
    PlayerInfo=GetRewardWeights(Filled, Rep, Decimal('0.1'))
    AdjLoadings=PlayerInfo['FirstL']
    #print('smoothrep: ' +str(PlayerInfo['SmoothRep']))#way wrong
    #print('Filled: ' +str(Filled))
    DecisionOutcomesRaw=custommath.dot([PlayerInfo['SmoothRep']], Filled)[0]
    #print('raw outcomes: ' +str(DecisionOutcomesRaw))
    DecisionOutcomeAdj=map(lambda x: custommath.Catch(x, CatchP), DecisionOutcomesRaw)
    Certainty=map(lambda x: 2*(x-Decimal('0.5')), DecisionOutcomesRaw)
    Certainty=map(abs, Certainty)
    ConReward=custommath.GetWeight(Certainty)
    Avg_Certainty=custommath.mean(Certainty)
    DecisionOutcomeAdj=[]
    for i, raw in enumerate(DecisionOutcomesRaw):
        DecisionOutcomeAdj.append(custommath.Catch(raw, CatchP))
    DecisionOutcomeFinal=DecisionOutcomeAdj
    NAmat=map(lambda row: map(lambda x: 1 if type(x) in [str, unicode] else 0, row), M0)
    a=custommath.dot([PlayerInfo['SmoothRep']], NAmat)[0]
    ParticipationC=map(lambda x: 1-x, a)
    v=map(sum, NAmat)
    ParticipationR=map(lambda x: 1-x/Decimal(len(NAmat[0])), v)
    PercentNA=1-custommath.mean(ParticipationC)
    NAbonusR = custommath.GetWeight(ParticipationR)
    def plus(a, b): return a+b
    RowBonus = map(plus, map(lambda x: x*PercentNA, NAbonusR), map(lambda x: x*(1-PercentNA),  PlayerInfo['SmoothRep']))
    NAbonusC=custommath.GetWeight(ParticipationC)
    ColBonus=map(plus, map(lambda x: x*PercentNA, NAbonusC), map(lambda x: x*(1-PercentNA), ConReward))
    namatsum=[]
    for i in range(len(NAmat[0])):
        namatsum.append(sum(map(lambda x: x[i], NAmat)))
    Output = {
        'Original': M0,
        'Filled': Filled,
        'Agents': {
            'OldRep': PlayerInfo['OldRep'],#[0],
            'ThisRep': PlayerInfo['ThisRep'],
            'SmoothRep': PlayerInfo['SmoothRep'],
            'NArow': map(sum, NAmat),#.sum(axis=1).base,
            'ParticipationR': ParticipationR,#.base,
            'RelativePart': NAbonusR,#.base,
            'RowBonus': RowBonus,#.base,
        },
        'Decisions': {
            'First Loading': AdjLoadings,
            'DecisionOutcomes_Raw': DecisionOutcomesRaw,
            'Consensus Reward': ConReward,
            'Certainty': Certainty,
            'NAs Filled': namatsum,#NAmat.sum(axis=0),
            'ParticipationC': ParticipationC,
            'Author Bonus': ColBonus,
            'DecisionOutcome_Final': DecisionOutcomeFinal,
        },
        'Participation': 1 - PercentNA,
        'Certainty': Avg_Certainty,
    }
    return Output

from ConsensusMechanism import *
def test_GetRewardWeights():
    M = [[1, 1, 0, 0],
         [1, 0, 0, 0],
         [1, 1, 0, 0],
         [1, 1, 1, 0],
         [0, 0, 1, 1],
         [0, 0, 1, 1]]
    '''
{u'ThisRep': array([[ 0.2823757,  0.2176243,  0.2823757,  0.2176243,  0.       ,  0.       ]]), u'FirstL': array([-0.5395366 , -0.45705607,  0.45705607,  0.5395366 ]), u'SmoothRep': array([[ 0.17823757,  0.17176243,  0.17823757,  0.17176243,  0.15      ,
         0.15      ]]), u'OldRep': array([[ 0.16666667,  0.16666667,  0.16666667,  0.16666667,  0.16666667,
         0.16666667]])}
    '''
    import pprint
    pprint.pprint(GetRewardWeights(M))
def test_getdecisionoutcomes():
    M=[[1,    1,    0,    0],
       [1,    0,    0,    0],
       [1,    1,    0,    0],
       [1,    1,    1,    0],
       [0,    0,    1,    1],
       [0,    0,    1,    1]]
    print(GetDecisionOutcomes(M, [1]*6))
    #[[Decimal('0.6666666666666666666666666668'), Decimal('0.5000000000000000000000000001'), Decimal('0.5000000000000000000000000001'), Decimal('0.3333333333333333333333333334')]]
def FillNa_test():
    M=[[1,    1,    0,    0],
       [1,    0,    'NA',    'NA'],
       [1,    'NA',    0,    'NA'],
       [1,    1,    1,    'NA'],
       [0,    'NA',    1,    'NA'],
       [0,    0,    1,    1]]
    print(FillNa(M, [1,1,1,1,1,1]))
#[[Decimal('1'), Decimal('1'), Decimal('0'), Decimal('0')], [Decimal('1'), Decimal('0'), Decimal('1'), Decimal('0.5')], [Decimal('1'), Decimal('0.5'), Decimal('0'), Decimal('0.5')], [Decimal('1'), Decimal('1'), Decimal('1'), Decimal('0.5')], [Decimal('0'), Decimal('0.5'), Decimal('1'), Decimal('0.5')], [Decimal('0'), Decimal('0'), Decimal('1'), Decimal('1')]]
def Factory_test():
    import pprint
    M1=[[1,    1,    0,    'NA'],
        [1,    0,    0,    0],
        [1,    1,    0,    0],
        [1,    1,    1,    0],
        [0,    0,    1,    1],
        [0,    0,    1,    1]]
    pprint.pprint(Factory(M1, [1,1,1,1,1,1]))
#Factory_test()
from cdecimal import Decimal
import copy, svd
def AsMatrix(v): return map(lambda i: [i], v)
def matrix_p(v): return type(v[0])==list
def mean(v): return sum(v)*Decimal('1.0')/len(v)
def replace_na(x, m):
    if type(x) in [int, float]:
        return x
    return m
def GetWeight(Vec, AddMean=False):
    new=map(abs, Vec)
    m=mean(new)
    tot=sum(new)
    if AddMean: new=map(lambda x: x+m, new)
    if(tot==0): new=map(lambda x: x+1, new)
    s=Decimal(sum(new))
    new=map(lambda x: Decimal(x)/s, new)
    return new
def dec_greater_than(a, b): return float(a)>float(b)
def Catch(X, Tolerance=0):
    h=Decimal('0.5')
    t=Tolerance/2
    if dec_greater_than(X,h+t):
        return Decimal('1')
    if dec_greater_than(h-t, X):
        return Decimal('0')
    return Decimal('0.5')
def median_walker(so_far_w, limit, x, w, prev_x):
    if so_far_w>limit: return prev_x
    if so_far_w==limit: return mean([Decimal('1.0')*prev_x, x[0]])
    return median_walker(so_far_w+w[0], limit, x[1:], w[1:], x[0])
def weighted_median(x, w):
    x, w=zip(*sorted(zip(x, w)))
    return median_walker(0, sum(w)*Decimal('1.0')/2, x, w, x[0])
def switch_row_cols(m):
    if not matrix_p(m):
        m=AsMatrix(m)
    out=[]
    for i in range(len(m[0])):
        newrow=[]
        for row in m:
            newrow.append(row[i])
        out.append(newrow)
    return out
def MeanNA(v):
    vf=filter(lambda x: type(x) in [int, float], v)
    m=mean(vf)
    return map(lambda x: replace_na(x, m), v)
def Rescale(UnscaledMatrix):
    flipped_m=switch_row_cols(UnscaledMatrix)
    out=[]
    for row in flipped_m:
        mrow=MeanNA(copy.deepcopy(row))
        ma=max(mrow)
        mi=min(mrow)
        out.append(map(lambda x: 'NA' if type(x)==str else (x-mi)/(ma-mi), row))
    return switch_row_cols(out)
def Influence(Weight):
    l=len(Weight)
    return map(lambda x: x*l, Weight)
def ReWeight(v):
    if type(v[0])==list: v=map(lambda x: x[0], v)
    w=map(lambda x: 0 if type(x)==str else x, v)
    s=sum(w)
    return map(lambda x: x*Decimal('1.0')/s, w)
def v2m(v):
    if not matrix_p(v):
        v=AsMatrix(v)
    return v
def dot(m, n):
    m=v2m(m)
    n=v2m(n)
    out=[]
    for i in range(len(m)):
        row=[]
        for j in range(len(n[0])):
            row.append(sum( m[i][k] * map(lambda x: x[j], n)[k] for k in range(len(m[0]))))
        out.append(row)
    return out
def weighted_sample_mean(matrix, weighting):
    weighting=ReWeight(weighting)
    matrix=dot(matrix, weighting)
    out=[]
    for i in range(len(matrix[0])):
        n=0
        for m in matrix:
            n+=m[i]
        out.append(n)
    return out
def subtract_vector(m, v):
    if type(v[0])==list and len(v[0])>1: v=v[0]
    if not matrix_p(v):
        v=AsMatrix(v)
    out=[]
    for row in range(len(m)):
        n=[]
        for column in range(len(v)):
            n.append(m[row][column]-v[column][0])
        out.append(n)
    return out
def v_average(M, W):
    M=copy.deepcopy(M)
    for row in range(len(M)):
        M[row]=map(lambda x: x*W[row],  M[row])
    out=[]
    for i in range(len(M[0])):
        n=0
        for j in range(len(M)):
            n+=M[j][i]
        out.append(n)
    return out
def ma_multiply(m, v):
    out=[]
    if type(v[0])==list and len(v)>0:#if v is vertical
        for row in range(len(m)):
            out.append(map(lambda x: x*v[row][0], m[row]))
    else:
        if type(v[0])==list: v=v[0]
        for row in range(len(m)):
            out.append(map(lambda i: m[row][i]*v[i], range(len(m[0]))))
    return out
def WeightedCov(Mat, Rep=-1):#should only output square matrices.
    if type(Rep) is int: Rep=map(lambda x: x/Decimal(len(Mat)), [1]*len(Mat))
    Coins=copy.deepcopy(Rep)
    #if type(Coins[0])==list: Coins=map(lambda x: x[0], Coins)
    Coins=map(lambda y: [y[0]*1000000], Coins)
    Mean=v_average(Mat, ReWeight(Coins))
    XM=subtract_vector(Mat, Mean)
    a=Decimal('1')/(sum(map(lambda x: x[0], Coins))-1)
    c=switch_row_cols(ma_multiply(XM,Coins))
    b=dot(c,XM)
    sigma2=map(lambda row: map(lambda x: x*a, row), b)
    return({'Cov':sigma2, 'Center':XM})
def WeightedPrinComp(M, Weights):
    if len(Weights)!=len(M):
        print('Weights must be equal in length to rows')
        return 'error'
    if type(Weights[0])!=list: Weights=map(lambda x: [x], Weights)
    wCVM=WeightedCov(M, Weights)
    SVD=svd.svd(wCVM['Cov'])
    L=switch_row_cols(SVD[0])[0]
    S=switch_row_cols(dot(wCVM['Center'], L))[0]
    return{'Scores':S, 'Loadings':L}
def test_GetWeight():
    print(GetWeight([1,1,1,1]))
    # [1] 0.25 0.25 0.25 0.25
    print(GetWeight([10,10,10,10]))
    # [1] 0.25 0.25 0.25 0.25
    print(GetWeight([4,5,6,7]))
    # [1] 0.1818182 0.2272727 0.2727273 0.3181818
    print(GetWeight([4,5,6,7], True))
    # [1] 0.2159091 0.2386364 0.2613636 0.2840909
def catch_test():
    print(Catch(Decimal('.4')))#0
    print(Catch(Decimal('.5')))#0.5
    print(Catch(Decimal('.6')))#1
    print(Catch(Decimal('.6'), Tolerance=Decimal('0.1')))#1
    print(Catch(Decimal('.6'), Tolerance=Decimal('0.2')))#0.5
def MeanNATest():
    v=[3,4,6,7,8]
    print(MeanNA(v))
    # [1] 3 4 6 7 8
    v=[3,'NA',6,7,8]
    print(MeanNA(v))
    # [1] 3 6 6 7 8
    v=[0,0,0,1,'NA']
    print(MeanNA(v))
    # [1] 0.00 0.00 0.00 1.00 0.25
    v=[0,0,'NA',1,'NA']
    print(MeanNA(v))
    # [1] 0.0000000 0.0000000 0.3333333 1.0000000 0.3333333
def rescale_test():
    m=[[1, 1, 0, 0],#, 233, Decimal(16027.59)],
       [1, 0, 0, 0],# 199, 'NA'],
       [1, 1, 0, 0],# 233, 16027.59],
       [1, 1, 1, 0],# 250, 'NA'],
       [0, 0, 1, 1],# 435, 8001.00],
       [0, 0, 1, 1]]#, 435, 19999.00]]
    print(Rescale(m))
def influence_test():
    print(Influence([Decimal('0.25')]*4))#[1,1,1,1]
    print(Influence([Decimal('0.3')]*2+[Decimal('0.4')]))#[0.9,0.9,1.2]
    print(Influence([Decimal('0.99')]+[Decimal('0.0025')]*4))
    ## [1] 4.9500 0.0125 0.0125 0.0125 0.0125
def reweight_test():
    print(ReWeight([1,1,1,1]))#[.25, .25, .25, .25]
    print(ReWeight(['NA',1,'NA',1]))#[0, .5, 0, .5]
    print(ReWeight([2,4,6,12]))## [1] 0.08333333 0.16666667 0.25000000 0.50000000
    print(ReWeight([2,4,'NA',12]))# [1] 0.1111111 0.2222222 0.0000000 0.6666667
def test_weighted_sample_mean():
    m=[[1,0,1],[1,1,1],[1,0,1]]
    c=[1,1,1]
    Mat=numpy.ma.masked_array(m)
    Coins=numpy.array(map(lambda x: [x], c))
    print(weighted_sample_mean(m, c))
    print(numpy.ma.average(Mat, axis=0, weights=numpy.hstack(Coins))) # Computing the weighted sample mean (fast, efficient and precise)
def test_subtract_vector():
    m=[[1,0,1],[1,1,1],[1,0,1]]
    Mat=numpy.ma.masked_array(m)
    v=[.5, .5, 0]
    #print(Mat)
    print(numpy.matrix(Mat-numpy.array(v)))
    print(subtract_vector(m, v))
def test_matrix_multiply():
    m=[[1,0,1],[1,1,1],[1,0,1]]
    Mat=numpy.ma.masked_array(m)
    coins=numpy.ma.masked_array([[1],[1],[2]])
    print(matrix_multiply(Mat, coins))
    print(numpy.ma.multiply(Mat, coins))
def dot_test():
    m=[[1,2,3],[1,0,0],[0,4,0]]
    m2=[[1],[1],[0]]
    Mat=numpy.ma.masked_array(m)
    Mat2=numpy.ma.masked_array(m2)
    a=numpy.dot(Mat, Mat2)
    b=dot(m, m2)
    print(a)
    print(b)
def v_average_test():
    import numpy.ma as ma
    M=[[1,1,0],[0,0,1],[0,1,0]]
    Coins=[100000,200000,300000]
    Mat=numpy.matrix(M)
    Mean = ma.average(Mat, axis=0, weights=numpy.hstack(Coins))
    print(Mean)
    print(v_average(M, ReWeight(Coins)))
def b_test():
    from numpy import ma as ma
    td=0.33333333333333333
    XM=[[-td, -td, 2*td],
        [2*td, 2*td, -td],
        [-td, -td, -td]]
    Coins=[1000000]*3
    print(ma.multiply(XM, Coins).T.dot(XM))
    print(dot(switch_row_cols(matrix_multiply(XM, Coins)), XM))
def weighted_cov_test():
    Mat=[[0,0,1],[1,1,0],[0,0,0]]
    print(WeightedCov(Mat, [1,1,1]))
def weighted_median_test():
    print(weighted_median([3,4,5],[Decimal('.2'),Decimal('.2'),Decimal('.6')]))
    print(weighted_median([3,4,5],[Decimal('.2'),Decimal('.2'),Decimal('.5')]))
    print(weighted_median([3,4,5],[Decimal('.2'),Decimal('.2'),Decimal('.4')]))
def dot_test():
    a=[[1,0],
       [0,1]]
    n=[[2,0],
       [0,1]]
    c=[[-33333.33333333,  66666.66666667, -33333.33333333],
       [-33333.33333333,  66666.66666667, -33333.33333333],
       [ 66666.66666667, -33333.33333333, -33333.33333333]]
    XM=[[-0.33333333, -0.33333333,  0.66666667],
        [ 0.66666667,  0.66666667, -0.33333333],
        [-0.33333333, -0.33333333, -0.33333333]]
    print(dot(c, XM))
    import numpy
    print(numpy.dot(c, XM))
def ma_multiply_test():
    XM=[[1,0,1,0],[0,1,0,0],[0,0,100, 0]]
    Coins=[[1],[2],[3]]
    from numpy import ma
    print(ma.multiply(XM, Coins))
    print(ma_multiply(XM, Coins))
    Coins=[1,2,3,4]
    print(ma.multiply(XM, Coins))
    print(ma_multiply(XM, Coins))
def weightedprincomp_test():
    import pprint
    M=[[0,0,1],[1,1,0],[0,0,0]]
    V=[Decimal('.1')]*3#]#, [Decimal('.1')], [Decimal('.8')], [Decimal('.1')]]
    a=WeightedPrinComp(M,V)
    pprint.pprint(WeightedPrinComp(M,V))
#from pyconsensus import *
from ConsensusMechanism import Factory

# Almost exact translation of the ALGOL SVD algorithm published in
# Numer. Math. 14, 403-420 (1970) by G. H. Golub and C. Reinsch
#
# by Thomas R. Metcalf, helicity314-stitch <at> yahoo <dot> com
#
# Pure Python SVD algorithm.
# Input: 2-D list (m by n) with m >= n
# Output: U,W V so that A = U*W*VT
#    Note this program returns V not VT (=transpose(V))
#    On error, a ValueError is raised.
#
# Here is the test case (first example) from Golub and Reinsch
#
# a = [[22.,10., 2.,  3., 7.],
#      [14., 7.,10.,  0., 8.],
#      [-1.,13.,-1.,-11., 3.],
#      [-3.,-2.,13., -2., 4.],
#      [ 9., 8., 1., -2., 4.],
#      [ 9., 1.,-7.,  5.,-1.],
#      [ 2.,-6., 6.,  5., 1.],
#      [ 4., 5., 0., -2., 2.]]
#
# import svd
# import math
# u,w,vt = svd.svd(a)
# print w
#
# [35.327043465311384, 1.2982256062667619e-15,
#  19.999999999999996, 19.595917942265423, 0.0]
#
# the correct answer is (the order may vary)
#
# print (math.sqrt(1248.),20.,math.sqrt(384.),0.,0.)
#
# (35.327043465311391, 20.0, 19.595917942265423, 0.0, 0.0)
#
# transpose and matrix multiplication functions are also included
# to facilitate the solution of linear systems.
#
# Version 1.0 2005 May 01


import copy
from cdecimal import Decimal
ten=Decimal('10')
one=Decimal('1')
zero=Decimal('0')
half=Decimal('0.5')
def sqrt(n): return n**half#return sqrt_h(n, decimal.Decimal(1))
def svd(a):
    '''Compute the singular value decomposition of array.'''

    # Golub and Reinsch state that eps should not be smaller than the
    # machine precision, ie the smallest number
    # for which 1+e>1.  tol should be beta/e where beta is the smallest
    # positive number representable in the computer.
    eps = ten**(-15)# assumes double precision
    tol = (ten**(-64))/eps
    assert one+eps > one # if this fails, make eps bigger
    assert tol > zero     # if this fails, make tol bigger
    itmax = 50
    u = copy.deepcopy(a)
    m = len(a)
    n = len(a[0])
    #if __debug__: print 'a is ',m,' by ',n

    if m < n:
        if __debug__: print 'Error: m is less than n'
        raise ValueError,'SVD Error: m is less than n.'

    e = [zero]*n  # allocate arrays
    q = [zero]*n
    v = []
    for k in range(n): v.append([zero]*n)
 
    # Householder's reduction to bidiagonal form

    g = zero
    x = zero

    for i in range(n):
        e[i] = g
        s = zero
        l = i+1
        for j in range(i,m): s += (u[j][i]*u[j][i])
        if s <= tol:
            g = zero
        else:
            f = u[i][i]
            if f < zero:
                g = sqrt(s)
            else:
                g = -sqrt(s)
            h = f*g-s
            u[i][i] = f-g
            for j in range(l,n):
                s = zero
                for k in range(i,m): s += u[k][i]*u[k][j]
                f = s/h
                for k in range(i,m): u[k][j] = u[k][j] + f*u[k][i]
        q[i] = g
        s = zero
        for j in range(l,n): s = s + u[i][j]*u[i][j]
        if s <= tol:
            g = zero
        else:
            f = u[i][i+1]
            if f < zero:
                g = sqrt(s)
            else:
                g = -sqrt(s)
            h = f*g - s
            u[i][i+1] = f-g
            for j in range(l,n): e[j] = u[i][j]/h
            for j in range(l,m):
                s=zero
                for k in range(l,n): s = s+(u[j][k]*u[i][k])
                for k in range(l,n): u[j][k] = u[j][k]+(s*e[k])
        y = abs(q[i])+abs(e[i])
        if y>x: x=y
    # accumulation of right hand gtransformations
    for i in range(n-1,-1,-1):
        if g != zero:
            h = g*u[i][i+1]
            for j in range(l,n): v[j][i] = u[i][j]/h
            for j in range(l,n):
                s=zero
                for k in range(l,n): s += (u[i][k]*v[k][j])
                for k in range(l,n): v[k][j] += (s*v[k][i])
        for j in range(l,n):
            v[i][j] = zero
            v[j][i] = zero
        v[i][i] = one
        g = e[i]
        l = i
    #accumulation of left hand transformations
    for i in range(n-1,-1,-1):
        l = i+1
        g = q[i]
        for j in range(l,n): u[i][j] = zero
        if g != zero:
            h = u[i][i]*g
            for j in range(l,n):
                s=zero
                for k in range(l,m): s += (u[k][i]*u[k][j])
                f = s/h
                for k in range(i,m): u[k][j] += (f*u[k][i])
            for j in range(i,m): u[j][i] = u[j][i]/g
        else:
            for j in range(i,m): u[j][i] = zero
        u[i][i] += one
    #diagonalization of the bidiagonal form
    eps = eps*x
    for k in range(n-1,-1,-1):
        for iteration in range(itmax):
            # test f splitting
            for l in range(k,-1,-1):
                goto_test_f_convergence = False
                if abs(e[l]) <= eps:
                    # goto test f convergence
                    goto_test_f_convergence = True
                    break  # break out of l loop
                if abs(q[l-1]) <= eps:
                    # goto cancellation
                    break  # break out of l loop
            if not goto_test_f_convergence:
                #cancellation of e[l] if l>0
                c = zero
                s = one
                l1 = l-1
                for i in range(l,k+1):
                    f = s*e[i]
                    e[i] = c*e[i]
                    if abs(f) <= eps:
                        #goto test f convergence
                        break
                    g = q[i]
                    h = pythag(f,g)
                    q[i] = h
                    c = g/h
                    s = -f/h
                    for j in range(m):
                        y = u[j][l1]
                        z = u[j][i]
                        u[j][l1] = y*c+z*s
                        u[j][i] = -y*s+z*c
            # test f convergence
            z = q[k]
            if l == k:
                # convergence
                if z<zero:
                    #q[k] is made non-negative
                    q[k] = -z
                    for j in range(n):
                        v[j][k] = -v[j][k]
                break  # break out of iteration loop and move on to next k value
            if iteration >= itmax-1:
                if __debug__: print 'Error: no convergence.'
                # should this move on the the next k or exit with error??
                #raise ValueError,'SVD Error: No convergence.'  # exit the program with error
                break  # break out of iteration loop and move on to next k
            # shift from bottom 2x2 minor
            x = q[l]
            y = q[k-1]
            g = e[k-1]
            h = e[k]
            f = ((y-z)*(y+z)+(g-h)*(g+h))/(2*one*h*y)
            g = pythag(f,one)
            if f < 0:
                f = ((x-z)*(x+z)+h*(y/(f-g)-h))/x
            else:
                f = ((x-z)*(x+z)+h*(y/(f+g)-h))/x
            # next QR transformation
            c = one
            s = one
            for i in range(l+1,k+1):
                g = e[i]
                y = q[i]
                h = s*g
                g = c*g
                z = pythag(f,h)
                e[i-1] = z
                c = f/z
                s = h/z
                f = x*c+g*s
                g = -x*s+g*c
                h = y*s
                y = y*c
                for j in range(n):
                    x = v[j][i-1]
                    z = v[j][i]
                    v[j][i-1] = x*c+z*s
                    v[j][i] = -x*s+z*c
                z = pythag(f,h)
                q[i-1] = z
                c = f/z
                s = h/z
                f = c*g+s*y
                x = -s*g+c*y
                for j in range(m):
                    y = u[j][i-1]
                    z = u[j][i]
                    u[j][i-1] = y*c+z*s
                    u[j][i] = -y*s+z*c
            e[l] = zero
            e[k] = f
            q[k] = x
            # goto test f splitting
        
            
    #vt = transpose(v)
    #return (u,q,vt)
    return (u,q,v)

def pythag(a,b):
    absa = abs(a)
    absb = abs(b)
    if absa > absb: return absa*sqrt(one+(absb/absa)**2)
    else:
        if absb == zero: return zero
        else: return absb*sqrt(one+(absa/absb)**2)

def transpose(a):
    '''Compute the transpose of a matrix.'''
    m = len(a)
    n = len(a[0])
    at = []
    for i in range(n): at.append([zero]*m)
    for i in range(m):
        for j in range(n):
            at[j][i]=a[i][j]
    return at

def matrixmultiply(a,b):
    '''Multiply two matrices.
    a must be two dimensional
    b can be one or two dimensional.'''
    
    am = len(a)
    bm = len(b)
    an = len(a[0])
    try:
        bn = len(b[0])
    except TypeError:
        bn = 1
    if an != bm:
        raise ValueError, 'matrixmultiply error: array sizes do not match.'
    cm = am
    cn = bn
    if bn == 1:
        c = [zero]*cm
    else:
        c = []
        for k in range(cm): c.append([zero]*cn)
    for i in range(cm):
        for j in range(cn):
            for k in range(an):
                if bn == 1:
                    c[i] += a[i][k]*b[k]
                else:
                    c[i][j] += a[i][k]*b[k][j]
    
    return c
if __name__ == "__main__":
    a = [[22.,10., 2.,  3., 7.],
         [14., 7.,10.,  0., 8.],
         [-1.,13.,-1.,-11., 3.],
         [-3.,-2.,13., -2., 4.],
         [ 9., 8., 1., -2., 4.],
         [ 9., 1.,-7.,  5.,-1.],
         [ 2.,-6., 6.,  5., 1.],
         [ 4., 5., 0., -2., 2.]]
    a=map(lambda row: map( lambda x: Decimal(x), row), a)
    u,w,vt = svd(a)
    print w
    print([35.327043465311384, 1.2982256062667619e-15, 19.999999999999996, 19.595917942265423, 0.0])
